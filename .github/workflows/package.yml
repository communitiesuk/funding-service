name: CNB build
run-name: Build ${{github.ref_name}}

permissions:
  contents: read  # This is required for actions/checkout
  id-token: write  # This is required for authenticating with aws

on:
  workflow_call:
    secrets:
      AWS_ACCOUNT:
        required: true
      SLACK_BOT_TOKEN:
        required: true
      TEMP_SLACK_CHANNEL_ID:
        required: true
      CI_AWS_ACCOUNT:
        required: true
env:
  BUILDER_IMAGE: heroku/builder:24

jobs:
  cnb_build:
    runs-on: ubuntu-latest
    name: Build
    steps:
      - uses: buildpacks/github-actions/setup-pack@272592019840154a9e6919abf147eaffe6845877 # v5.9.5
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5

      - name: Configure AWS credentials using OIDC
        uses: aws-actions/configure-aws-credentials@00943011d9042930efac3dcd3a170e4273319bc8 # v5
        with:
          role-to-assume: arn:aws:iam::${{ secrets.CI_AWS_ACCOUNT }}:role/terraform-developer
          aws-region: eu-west-2  # adjust as needed

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@d63b14614fe5d7fc5e5e52c523dea4e876816cc4

      - name: Check if image exists in ECR
        id: check_image_exists_in_ecr
        run: |
          AWS_REGION="eu-west-2"
          REPO_NAME="funding-service-ci-shared-app"
          IMAGE_TAG=${{ github.sha }}

          # the script should only fail for network or config failures, a missing image tag will successfully return nothing
          REMOTE_IMAGE_TAG="$(aws ecr batch-get-image --repository-name=$REPO_NAME --image-ids=imageTag=$IMAGE_TAG --query 'images[].imageId.imageTag' --output=text --region $AWS_REGION)"

          if [[ $IMAGE_TAG == $REMOTE_IMAGE_TAG ]]; then
            # CI image tags are immutable and cannot be overridden
            echo "image_exists=true" >> $GITHUB_OUTPUT
          else
            echo "image_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Get builder digest
        id: builder-digest
        run: |
         set -euo pipefail

         REF="${BUILDER_IMAGE}"
         OS="linux"
         # Map uname to Docker arch labels
         UNAME_ARCH="$(uname -m)"
         case "$UNAME_ARCH" in
           x86_64) ARCH="amd64" ;;
           aarch64|arm64) ARCH="arm64" ;;
           *) echo "Unknown arch: $UNAME_ARCH"; exit 1 ;;
         esac

         # Query the remote manifest list and select the per-platform digest
         DIGEST=$(
           docker manifest inspect -v "$REF" \
             | jq -r --arg os "$OS" --arg arch "$ARCH" \
                 '.[] | select(.Descriptor.platform.os==$os and .Descriptor.platform.architecture==$arch) | .Descriptor.digest' \
             | head -n1
         )

         if [[ -z "${DIGEST}" || "${DIGEST}" == "null" ]]; then
           echo "Failed to resolve digest for $REF ($OS/$ARCH)."; exit 1
         fi

         echo "digest=${DIGEST}" >> "$GITHUB_OUTPUT"

      - name: Restore cached builder
        uses: actions/cache@v4
        with:
          path: builder.tar.zst
          key: builder-${{ env.BUILDER_IMAGE }}-${{ steps.builder-digest.outputs.digest }}


      - name: Load or pull builder from mirror or original
        run: |
          set -euo pipefail
          IMAGE="${BUILDER_IMAGE}"
          OUT="builder.tar"
          MIRRORS=("mirror.gcr.io" "registry-1.docker.io")

          pulled=false
          for mirror in "${MIRRORS[@]}"; do
            echo "Trying mirror: $mirror/$IMAGE"
            if docker pull "${mirror}/${IMAGE}" 2>/dev/null; then
              docker tag "${mirror}/${IMAGE}" "${IMAGE}"
              pulled=true
              break
            fi
          done

          if [ "$pulled" = false ]; then
            echo "Falling back to original: $IMAGE"
            docker pull "${IMAGE}"
          fi

          echo "Saving builder image to cache: ${OUT}"
          docker save "${IMAGE}" -o "${OUT}" | zstd -T0 -o builder.tar.zst


      - name: Build and publish to ECR
        id: build_and_publish
        if: steps.check_image_exists_in_ecr.outputs.image_exists == 'false'
        run: |
          AWS_ACCOUNT_ID=${{ secrets.CI_AWS_ACCOUNT}}
          AWS_REGION="eu-west-2"
          REPO_NAME="funding-service-ci-shared-app"
          IMAGE_TAG=${{ github.sha }}

          ECR_BASE_URI="$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$REPO_NAME"
          ECR_IMAGE_URI="$ECR_BASE_URI:$IMAGE_TAG"
          ECR_CACHE_BUILD_IMAGE_URI="$ECR_BASE_URI-cache:latest"
          echo "::add-mask::$ECR_IMAGE_URI"

          pack config registry-mirrors add index.docker.io --mirror "mirror.gcr.io"

          pack build "$ECR_IMAGE_URI" --builder ${{ env.BUILDER_IMAGE }} \
          --cache-image "$ECR_CACHE_BUILD_IMAGE_URI" \
          --pull-policy if-not-present \
          --publish


  notify_slack:
      needs:
        - cnb_build
      secrets:
        SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
        SLACK_NOTIFICATION_CHANNEL_ID: ${{ secrets.TEMP_SLACK_CHANNEL_ID }}
      if: ${{ always() && needs.cnb_build.result == 'failure' && github.ref_name == 'main'}}
      uses: communitiesuk/funding-service-design-workflows/.github/workflows/notify-slack-deployment-failed.yml@main
      with:
        app_name: FS CNB
        env_name: 'build'
        github_username: ${{ github.actor }}
        workflow_url: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
        compare_url: ${{ github.event_name == 'push' && github.event.compare || null }}
